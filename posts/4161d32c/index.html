<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"right",display:"post",offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="Kafka最初是由Linkedin公司开发的消息引擎，后来捐赠给了Apache软件基金会。起初，人们说Kafka是一个可扩展的，支持发布-订阅模式的消息系统；后来，人们说Kafka是一个实时数据管道；再后来，人们又说Kafka是一个分布式复制日志系统，可构建统一的企业数据集成堆栈；现在，Apache Kafka的官网说Kafka是一个分布式流平台。其实，这些说法都对，Kafka是一个不断迭代演进的"><meta name="keywords" content="kafka"><meta property="og:type" content="article"><meta property="og:title" content="kafka介绍"><meta property="og:url" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;index.html"><meta property="og:site_name" content="有翼"><meta property="og:description" content="Kafka最初是由Linkedin公司开发的消息引擎，后来捐赠给了Apache软件基金会。起初，人们说Kafka是一个可扩展的，支持发布-订阅模式的消息系统；后来，人们说Kafka是一个实时数据管道；再后来，人们又说Kafka是一个分布式复制日志系统，可构建统一的企业数据集成堆栈；现在，Apache Kafka的官网说Kafka是一个分布式流平台。其实，这些说法都对，Kafka是一个不断迭代演进的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;001.png"><meta property="og:image" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;002.png"><meta property="og:image" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;003.png"><meta property="og:image" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;004.png"><meta property="og:image" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;005.png"><meta property="og:image" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;006.png"><meta property="og:updated_time" content="2019-10-19T13:29:02.487Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;huagetai.github.io&#x2F;posts&#x2F;4161d32c&#x2F;001.png"><link rel="canonical" href="https://huagetai.github.io/posts/4161d32c/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>kafka介绍 | 有翼</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">有翼</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">心若有翼，我自飞翔</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook" rel="section"><i class="fa fa-fw fa-comment"></i>留言</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://huagetai.github.io/posts/4161d32c/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="worry"><meta itemprop="description" content="认真做事，踏实做人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="有翼"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">kafka介绍</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-08 15:53:46" itemprop="dateCreated datePublished" datetime="2019-10-08T15:53:46+08:00">2019-10-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-19 21:29:02" itemprop="dateModified" datetime="2019-10-19T21:29:02+08:00">2019-10-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/kafka/" itemprop="url" rel="index"><span itemprop="name">kafka</span> </a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/posts/4161d32c/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/4161d32c/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>17 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>Kafka最初是由Linkedin公司开发的消息引擎，后来捐赠给了Apache软件基金会。起初，人们说Kafka是一个可扩展的，支持发布-订阅模式的消息系统；后来，人们说Kafka是一个实时数据管道；再后来，人们又说Kafka是一个分布式复制日志系统，可构建统一的企业数据集成堆栈；现在，Apache Kafka的官网说Kafka是一个分布式流平台。其实，这些说法都对，Kafka是一个不断迭代演进的系统，从最初的发布-订阅模式的消息系统逐步发展成为一个分布式流数据处理平台。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Kafka作为一个分布式流处理平台。需要提供以下三种特性:</p><ol><li>发布和订阅流式的记录。这一方面与消息队列或者企业消息系统类似。</li><li>储存流式记录，并且提供较好的容错性。</li><li>在流式记录产生时就进行处理。</li></ol><p>Kafka可以用于构建两大类别的应用:</p><ol><li>构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。 (相当于message queue)</li><li>构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)</li></ol><p>Kafka作为一个集群，运行在一台或者多台服务器上。Kafka通过 <em>Topic</em> 对存储的流数据进行分类。每条记录中包含一个key，一个value和一个timestamp（时间戳）</p><p>Kafka提供四个核心的API:</p><ul><li><a href="http://kafka.apachecn.org/documentation.html#producerapi" target="_blank" rel="noopener">Producer API</a> 允许一个应用程序发布一串流式的数据到一个或者多个topic。</li><li><a href="http://kafka.apachecn.org/documentation.html#consumerapi" target="_blank" rel="noopener">Consumer API</a> 允许一个应用程序订阅一个或多个 topic ，并且对发布给他们的流式数据进行处理。</li><li><a href="http://kafka.apachecn.org/documentation/streams" target="_blank" rel="noopener">Streams API</a> 允许一个应用程序作为一个<em>流处理器</em>，消费一个或者多个topic产生的输入流，然后生产一个输出流到一个或多个topic中去，在输入输出流中进行有效的转换。</li><li><a href="http://kafka.apachecn.org/documentation.html#connect" target="_blank" rel="noopener">Connector API</a> 允许构建并运行可重用的生产者或者消费者，将topics连接到已存在的应用程序或者数据系统。比如，连接到一个关系型数据库，捕捉表（table）的所有变更内容。</li></ul><p>下面这张图对kafka的整体功能做了一个形象化的描述。</p><img src="/posts/4161d32c/001.png"><p>在Kafka中，客户端和服务器使用一个简单、高性能、支持多语言的 <a href="https://kafka.apache.org/protocol.html" target="_blank" rel="noopener">TCP 协议</a>.此协议版本化并且向下兼容老版本， 我们为Kafka提供了Java客户端，也支持许多<a href="https://cwiki.apache.org/confluence/display/KAFKA/Clients" target="_blank" rel="noopener">其他语言的客户端</a>。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。</p><h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><img src="/posts/4161d32c/002.png"><h2 id="主题和分区"><a href="#主题和分区" class="headerlink" title="主题和分区"></a>主题和分区</h2><p>Topic 就是数据主题，是数据记录发布的地方,可以用来区分业务系统。Kafka中的Topics总是多订阅者模式，一个topic可以拥有一个或者多个消费者来订阅它的数据。</p><p>对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：</p><img src="/posts/4161d32c/003.png"><p>每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，<em>offset</em>用来唯一的标识分区中每一条记录。</p><p>Kafka 集群保留所有发布的记录—无论他们是否已被消费—并通过一个可配置的参数——保留期限来控制. 举个例子， 如果保留策略设置为2天，一条记录发布后两天内，可以随时被消费，两天过后这条记录会被抛弃并释放磁盘空间。Kafka的性能和数据大小无关，所以长时间存储数据没有什么问题.</p><img src="/posts/4161d32c/004.png"><p>事实上，在每一个消费者中唯一保存的元数据是offset（偏移量）即消费在log中的位置.偏移量由消费者所控制:通常在读取记录后，消费者会以线性的方式增加偏移量，但是实际上，由于这个位置由消费者控制，所以消费者可以采用任何顺序来消费记录。例如，一个消费者可以重置到一个旧的偏移量，从而重新处理过去的数据；也可以跳过最近的记录，从”现在”开始消费。</p><p>这些细节说明Kafka 消费者是非常廉价的—-消费者的增加和减少，对集群或者其他消费者没有多大的影响。比如，你可以使用命令行工具，对一些topic内容执行 tail操作，并不会影响已存在的消费者消费数据。</p><p>日志中的 partition（分区）有以下几个用途。第一，当日志大小超过了单台服务器的限制，允许日志进行扩展。每个单独的分区都必须受限于主机的文件限制，不过一个主题可能有多个分区，因此可以处理无限量的数据。第二，可以作为并行的单元集，分布在多个服务器上，确保容错性，实现集群的负载均衡。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>日志的分区partition （分布）在Kafka集群的服务器上。每个服务器在处理数据和请求时，共享这些分区。每一个分区都会在已配置的服务器上进行备份，确保容错性.</p><p>每个分区都有一台 server 作为 “leader”，零台或者多台server作为 follwers 。leader server 处理一切对 partition （分区）的读写请求，而follwers只需被动的同步leader上的数据。当leader宕机了，followers 中的一台服务器会自动成为新的 leader。每台 server 都会成为某些分区的 leader 和某些分区的 follower，因此集群的负载是平衡的。</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>生产者可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(例如：记录中的key)来完成。下面会介绍更多关于分区的使用。</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费者使用一个 <em>消费组</em> 名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例.消费者实例可以分布在多个进程中或者多个机器上。</p><p>如果所有的消费者实例在同一消费组中，消息记录会负载平衡到每一个消费者实例.</p><p>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程.</p><img src="/posts/4161d32c/005.png"><p>如图，这个 Kafka 集群有两台 server 的，四个分区(p0-p3)和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。</p><p>通常情况下，每个 topic 都会有一些消费组，一个消费组对应一个”逻辑订阅者”。一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个的进程。</p><p>在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，每个实例都是分区唯一的消费者。维护消费组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些 partition 分区;如果一个实例消失，拥有的分区将被分发到剩余的实例。</p><p>Kafka 只保证分区内的记录是有序的，而不保证主题中不同分区的顺序。每个 partition 分区按照key值排序足以满足大多数应用程序的需求。但如果你需要总记录在所有记录的上面，可使用仅有一个分区的主题来实现，这意味着每个消费者组只有一个消费者进程。</p><h2 id="可靠性保证"><a href="#可靠性保证" class="headerlink" title="可靠性保证"></a>可靠性保证</h2><p>high-level Kafka给予以下保证:</p><ul><li>生产者发送到特定topic partition 的消息将按照发送的顺序处理。 也就是说，如果记录M1和记录M2由相同的生产者发送，并先发送M1记录，那么M1的偏移比M2小，并在日志中较早出现</li><li>一个消费者实例按照日志中的顺序查看记录.</li><li>对于具有N个副本的主题，我们最多容忍N-1个服务器故障，从而保证不会丢失任何提交到日志中的记录.</li></ul><h2 id="Kafka作为消息系统"><a href="#Kafka作为消息系统" class="headerlink" title="Kafka作为消息系统"></a>Kafka作为消息系统</h2><p>Kafka streams的概念与传统的企业消息系统相比如何？</p><p>传统的消息系统有两个模块: <a href="http://en.wikipedia.org/wiki/Message_queue" target="_blank" rel="noopener">队列</a> 和 <a href="http://en.wikipedia.org/wiki/Publish–subscribe_pattern" target="_blank" rel="noopener">发布-订阅</a>。 在队列中，消费者池从server读取数据，每条记录被池子中的一个消费者消费; 在发布订阅中，记录被广播到所有的消费者。两者均有优缺点。 队列的优点在于它允许你将处理数据的过程分给多个消费者实例，使你可以扩展处理过程。 不好的是，队列不是多订阅者模式的—一旦一个进程读取了数据，数据就会被丢弃。 而发布-订阅系统允许你广播数据到多个进程，但是无法进行扩展处理，因为每条消息都会发送给所有的订阅者。</p><p>消费组在Kafka有两层概念。在队列中，消费组允许你将处理过程分发给一系列进程(消费组中的成员)。 在发布订阅中，Kafka允许你将消息广播给多个消费组。</p><p>Kafka的优势在于每个topic都有以下特性—可以扩展处理并且允许多订阅者模式—不需要只选择其中一个.</p><p>Kafka相比于传统消息队列还具有更严格的顺序保证</p><p>传统队列在服务器上保存有序的记录，如果多个消费者消费队列中的数据， 服务器将按照存储顺序输出记录。 虽然服务器按顺序输出记录，但是记录被异步传递给消费者， 因此记录可能会无序的到达不同的消费者。这意味着在并行消耗的情况下， 记录的顺序是丢失的。因此消息系统通常使用“唯一消费者”的概念，即只让一个进程从队列中消费， 但这就意味着不能够并行地处理数据。</p><p>Kafka 设计的更好。topic中的partition是一个并行的概念。 Kafka能够为一个消费者池提供顺序保证和负载平衡，是通过将topic中的partition分配给消费者组中的消费者来实现的， 以便每个分区由消费组中的一个消费者消耗。通过这样，我们能够确保消费者是该分区的唯一读者，并按顺序消费数据。 众多分区保证了多个消费者实例间的负载均衡。但请注意，消费者组中的消费者实例个数不能超过分区的数量。</p><h2 id="Kafka-作为存储系统"><a href="#Kafka-作为存储系统" class="headerlink" title="Kafka 作为存储系统"></a>Kafka 作为存储系统</h2><p>许多消息队列可以发布消息，除了消费消息之外还可以充当中间数据的存储系统。那么Kafka作为一个优秀的存储系统有什么不同呢?</p><p>数据写入Kafka后被写到磁盘，并且进行备份以便容错。直到完全备份，Kafka才让生产者认为完成写入，即使写入失败Kafka也会确保继续写入</p><p>Kafka使用磁盘结构，具有很好的扩展性—50kb和50TB的数据在server上表现一致。</p><p>可以存储大量数据，并且可通过客户端控制它读取数据的位置，您可认为Kafka是一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。</p><h2 id="Kafka用做流处理"><a href="#Kafka用做流处理" class="headerlink" title="Kafka用做流处理"></a>Kafka用做流处理</h2><p>Kafka 流处理不仅仅用来读写和存储流式数据，它最终的目的是为了能够进行实时的流处理。</p><p>在Kafka中，流处理器不断地从输入的topic获取流数据，处理数据后，再不断生产流数据到输出的topic中去。例如，零售应用程序可能会接收销售和出货的输入流，经过价格调整计算后，再输出一串流式数据。</p><p>简单的数据处理可以直接用生产者和消费者的API。对于复杂的数据变换，Kafka提供了Streams API。 Stream API 允许应用做一些复杂的处理，比如将流数据聚合或者join。</p><p>这一功能有助于解决以下这种应用程序所面临的问题：处理无序数据，当消费端代码变更后重新处理输入，执行有状态计算等。</p><p>Streams API建立在Kafka的核心之上：它使用Producer和Consumer API作为输入，使用Kafka进行有状态的存储， 并在流处理器实例之间使用相同的消费组机制来实现容错。</p><h2 id="Kafka就是一个分布式流数据平台"><a href="#Kafka就是一个分布式流数据平台" class="headerlink" title="Kafka就是一个分布式流数据平台"></a>Kafka就是一个分布式流数据平台</h2><p>将消息、存储和流处理结合起来，使得Kafka看上去不一般，但这是它作为流平台所备的.</p><p>像HDFS这样的分布式文件系统可以存储用于批处理的静态文件。 一个系统如果可以存储和处理历史数据是非常不错的。</p><p>传统的企业消息系统允许处理订阅后到达的数据。以这种方式来构建应用程序，并用它来处理即将到达的数据。</p><p>Kafka结合了上面所说的两种特性。作为一个流应用程序平台或者流数据管道，这两个特性，对于Kafka 来说是至关重要的。</p><p>通过组合存储和低延迟订阅，流式应用程序可以以同样的方式处理过去和未来的数据。 一个单一的应用程序可以处理历史记录的数据，并且可以持续不断地处理以后到达的数据，而不是在到达最后一条记录时结束进程。 这是一个广泛的流处理概念，其中包含批处理以及消息驱动应用程序</p><p>同样，作为流数据管道，能够订阅实时事件使得Kafk具有非常低的延迟; 同时Kafka还具有可靠存储数据的特性，可用来存储重要的支付数据， 或者与离线系统进行交互，系统可间歇性地加载数据，也可在停机维护后再次加载数据。流处理功能使得数据可以在到达时转换数据。</p><img src="/posts/4161d32c/006.png"><h2 id="核心概念总结"><a href="#核心概念总结" class="headerlink" title="核心概念总结"></a>核心概念总结</h2><ol><li><strong>Record/Message</strong>：消息，Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。</li><li><strong>Offset</strong>：消息位移，表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li><li><strong>Topic</strong>：主题，主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</li><li><strong>Partition</strong>：分区，一个有序不变的消息序列。每个主题下可以有多个分区。</li><li><strong>Broker</strong>：代理，消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</li><li><strong>Leader</strong>：领导者</li><li><strong>Follower</strong>：追随者</li><li><strong>Replica</strong>：副本，Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li><li><strong>Producer</strong>：生产者，向主题发布消息的应用程序。</li><li><strong>Consumer</strong>：消费者，从主题订阅消息的应用程序。</li><li><strong>Consumer Group</strong>：消费者组，多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li><li><strong>Consumer Offset</strong>：消费者位移，表征消费者消费进度，每个消费者都有自己的消费者位移。</li><li><strong>Rebalance</strong>：重平衡，消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li></ol><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>以下描述了一些 ApacheKafka ®的流行用例。有关这些领域的概述，请参阅 <a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/" target="_blank" rel="noopener">此博客中的文章</a>。</p><p><strong>消息</strong></p><p>Kafka 很好地替代了传统的message broker（消息代理）。 Message brokers 可用于各种场合（如将数据生成器与数据处理解耦，缓冲未处理的消息等）。 与大多数消息系统相比，Kafka拥有更好的吞吐量、内置分区、具有复制和容错的功能，这使它成为一个非常理想的大型消息处理应用。</p><p>根据我们的经验，通常消息传递使用较低的吞吐量，但可能要求较低的端到端延迟，Kafka提供强大的持久性来满足这一要求。</p><p>在这方面，Kafka 可以与传统的消息传递系统（<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a> 和 <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>）相媲美。</p><p><strong>跟踪网站活动</strong></p><p>Kafka 的初始用例是将用户活动跟踪管道重建为一组实时发布-订阅源。 这意味着网站活动（浏览网页、搜索或其他的用户操作）将被发布到中心topic，其中每个活动类型有一个topic。 这些订阅源提供一系列用例，包括实时处理、实时监视、对加载到Hadoop或离线数据仓库系统的数据进行离线处理和报告等。</p><p>每个用户浏览网页时都生成了许多活动信息，因此活动跟踪的数据量通常非常大</p><p><strong>度量</strong></p><p>Kafka 通常用于监控数据。这涉及到从分布式应用程序中汇总数据，然后生成可操作的集中数据源。</p><p><strong>日志聚合</strong></p><p>许多人使用Kafka来替代日志聚合解决方案。 日志聚合系统通常从服务器收集物理日志文件，并将其置于一个中心系统（可能是文件服务器或HDFS）进行处理。 Kafka 从这些日志文件中提取信息，并将其抽象为一个更加清晰的消息流。 这样可以实现更低的延迟处理且易于支持多个数据源及分布式数据的消耗。 与Scribe或Flume等以日志为中心的系统相比，Kafka具备同样出色的性能、更强的耐用性（因为复制功能）和更低的端到端延迟。</p><p><strong>流处理</strong></p><p>许多Kafka用户通过管道来处理数据，有多个阶段： 从Kafka topic中消费原始输入数据，然后聚合，修饰或通过其他方式转化为新的topic， 以供进一步消费或处理。 例如，一个推荐新闻文章的处理管道可以从RSS订阅源抓取文章内容并将其发布到“文章”topic; 然后对这个内容进行标准化或者重复的内容， 并将处理完的文章内容发布到新的topic; 最终它会尝试将这些内容推荐给用户。 这种处理管道基于各个topic创建实时数据流图。从0.10.0.0开始，在Apache Kafka中，<a href="http://kafka.apachecn.org/documentation/streams" target="_blank" rel="noopener">Kafka Streams</a> 可以用来执行上述的数据处理，它是一个轻量但功能强大的流处理库。除Kafka Streams外，可供替代的开源流处理工具还包括<a href="https://storm.apache.org/" target="_blank" rel="noopener">Apache Storm</a> 和<a href="http://samza.apache.org/" target="_blank" rel="noopener">Apache Samza</a>.</p><p><strong>采集日志</strong></p><p><a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank" rel="noopener">Event sourcing</a>是一种应用程序设计风格，按时间来记录状态的更改。 Kafka 可以存储非常多的日志数据，为基于 event sourcing 的应用程序提供强有力的支持。</p><p><strong>提交日志</strong></p><p>Kafka 可以从外部为分布式系统提供日志提交功能。 日志有助于记录节点和行为间的数据，采用重新同步机制可以从失败节点恢复数据。 Kafka的<a href="http://kafka.apachecn.org/documentation.html#compaction" target="_blank" rel="noopener">日志压缩</a> 功能支持这一用法。 这一点与<a href="http://zookeeper.apache.org/bookkeeper/" target="_blank" rel="noopener">Apache BookKeeper</a> 项目类似。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/kafka/" rel="tag"># kafka</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/c85ca198/" rel="next" title="【整理】日志-每个软件工程师都应该知道的有关实时数据的统一抽象"><i class="fa fa-chevron-left"></i> 【整理】日志-每个软件工程师都应该知道的有关实时数据的统一抽象</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/2eee52f0/" rel="prev" title="【整理】饶军-Apache Kafka的过去、现在和未来">【整理】饶军-Apache Kafka的过去、现在和未来 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-valine">valine</a></li><li class="tab"><a href="#comment-gitalk">gitalk</a></li></ul><div class="tab-content"><div class="tab-pane valine" id="comment-valine"><div class="comments" id="comments"></div></div><div class="tab-pane gitalk" id="comment-gitalk"><div class="comments" id="gitalk-container"></div></div></div></div><script>window.addEventListener('tabs:register', () => {
          let activeClass = 'valine';
            activeClass = localStorage.getItem('comments_active') || activeClass;
          if (activeClass) {
            let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
            if (activeTab) {
              activeTab.click();
            }
          }
        });
        window.addEventListener('tabs:click', event => {
          let commentClass = event.target.classList[1];
          localStorage.setItem('comments_active', commentClass);
        });</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#整体架构"><span class="nav-number">2.</span> <span class="nav-text">整体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整体架构图"><span class="nav-number">2.1.</span> <span class="nav-text">整体架构图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主题和分区"><span class="nav-number">2.2.</span> <span class="nav-text">主题和分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式"><span class="nav-number">2.3.</span> <span class="nav-text">分布式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者"><span class="nav-number">2.4.</span> <span class="nav-text">生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消费者"><span class="nav-number">2.5.</span> <span class="nav-text">消费者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可靠性保证"><span class="nav-number">2.6.</span> <span class="nav-text">可靠性保证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka作为消息系统"><span class="nav-number">2.7.</span> <span class="nav-text">Kafka作为消息系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka-作为存储系统"><span class="nav-number">2.8.</span> <span class="nav-text">Kafka 作为存储系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka用做流处理"><span class="nav-number">2.9.</span> <span class="nav-text">Kafka用做流处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka就是一个分布式流数据平台"><span class="nav-number">2.10.</span> <span class="nav-text">Kafka就是一个分布式流数据平台</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心概念总结"><span class="nav-number">2.11.</span> <span class="nav-text">核心概念总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用案例"><span class="nav-number">3.</span> <span class="nav-text">使用案例</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="worry" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">worry</p><div class="site-description" itemprop="description">认真做事，踏实做人</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/huagetai" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;huagetai" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:xiaochawan@126.com" title="E-Mail &amp;rarr; mailto:xiaochawan@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">worry</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">70k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">2:55</span></div><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=1000294390&web_id=1000294390"></script></div></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script><script src="/js/schemes/pisces.js?v=7.4.1"></script><script src="/js/next-boot.js?v=7.4.1"></script><script src="/js/local-search.js?v=7.4.1"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '9a74dfd7f89e23278636',
      clientSecret: 'b094b8a3e7018d48e6399825701002decd060d45',
      repo: 'huagetai.github.io',
      owner: 'huagetai',
      admin: ['huagetai'],
      id: 'b8ae7a733c9fc067a06350fdeab06990',
        language: 'zh-CN',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);</script><script>NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'MXw3KxWl0E0BqCmpb5hiJKlE-gzGzoHsz',
    appKey: 'ReqVUSvH190npS0g6Y7R9XIG',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);</script></body></html>